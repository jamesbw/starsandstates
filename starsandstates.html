<!DOCTYPE html>
<meta charset="utf-8">
<head> </head>
<script src="d3.v2.min.js"></script>
<style>

.background {
  fill: none;
  pointer-events: all;
}

#states {
  fill: #aaa;
  stroke: #fff;
  stroke-width: 1.5px;
}

#states .past {
  fill: steelblue;
}

#states .new {
  fill: red;
}

#states .motion {
  fill: red;
}

#slider {
  display: inline-block;
  width: 600px;
}

#year {
  position: relative;
}


.star {
  fill: white;
  stroke: black;
}

</style>
<body>
  <div id="svg_container"></div>
  <div style="text-align:center">
    <div>Year</div>
    <div style="display: inline-block" id="year"></div>
    <div/>
<span class="years">1750</span><input id="slider" type="range" min="1750" max="2012" step="1" value="1750" style="vertical-align: bottom" /><span class="years">2012</span>
</div>
<script>

  var albers_ratio = 960/500
  var svg_width = 1200,
      svg_height = svg_width / albers_ratio

//Map setup
//------------------------------------------------------

  var map_width = svg_width * 2/3
  var map_height = map_width / albers_ratio
  var map_top_right = {x: 100, y: 0}


  var projection = d3.geo.albersUsa()
      .scale(map_width )
      .translate([0, 0]);

  var path = d3.geo.path()
      .projection(projection);

  var svg = d3.select("#svg_container").append("svg")
      .attr("width", svg_width)
      .attr("height", svg_height);

  svg.append("rect")
      .attr("class", "background")
      .attr("width", svg_width)
      .attr("height", svg_height)

  var map_group = svg.append("g")
      .attr("transform", "translate(" + (map_width * 1/ 2 + map_top_right.x)+ "," + (map_height * 1/ 2 + map_top_right.y) + ")")
      .attr("id", "map")
    .append("g")
      .attr("id", "states");

  var x_map_to_global = d3.scale.linear()
                          .domain([0, map_width])
                          .range([map_top_right.x + map_width * 1/ 2, map_top_right.x + map_width * 1/ 2 + map_width])

  var y_map_to_global = d3.scale.linear()
                          .domain([0, map_height])
                          .range([map_height * 1/ 2 + map_top_right.y, map_height * 1/ 2 + map_top_right.y + map_height])



  //----------------------------------------


  //flag setup
  //------------------------------------------------------------------------------------------

  var flag_top_right = {x: map_width + map_top_right.x, y: 200}

  var flag_group = svg.append("g")
      .attr("transform", "translate(" +  flag_top_right.x+ "," + flag_top_right.y + ")")


  // Constant variables
  var flag_height = 200,
  flag_width = flag_height * 1.9,
  stripe_array = Array(13),
  stripe_h = flag_height/stripe_array.length,
  union_flag_h = stripe_h*7.,
  union_flag_w = flag_height*.76,
  star_r = stripe_h*1/125;


  // Flag - Stripes
  var stripes = flag_group.selectAll("rect.stripes")
  .data(stripe_array)
  .enter()
  .append("rect")
  .classed("stripes", true)
  .attr("width", flag_width)
  .attr("height", stripe_h)
  .style("fill", function(d, i) {
      return i % 2 ? "#fff" : "#CC0C2F";
  })
  .attr("y", function(d, i) {
      return i*stripe_h;
  });

  // Flag - Union Flag
  var union_flag = flag_group.append("rect")
  .classed("union_flag", true)
  .attr("width", union_flag_w)
  .attr("height", union_flag_h)
  .style("fill", "#002C77")
  // .on('click', moveStars);

  var x_flag_to_global = d3.scale.linear()
                          .domain([0, flag_width])
                          .range([flag_top_right.x, flag_top_right.x + flag_width])

  var y_flag_to_global = d3.scale.linear()
                          .domain([0, flag_height])
                          .range([flag_top_right.y, flag_top_right.y + flag_height])


  //-----------------------------------------------------------------------------------------

  d3.json("states_geo.json", function(json) {
    map_group.selectAll("path")
        .data(json.features)
      .enter().append("path")
        .attr("d", path)

    features = json.features
    centroids = json.features.map(function(feature){ return { name: feature.properties.name, centroid : path.centroid(feature)} })

    star_data = centroids.map(function(c){
      return {
        name: c.name,
        x: x_flag_to_global.invert( x_map_to_global(c.centroid[0])),
        y: y_flag_to_global.invert( y_map_to_global(c.centroid[1])),
        scale: undefined,
        rotation: undefined,
        opacity: undefined
      }
    })

  });


  function color_states(state_names, class_name) {
    map_group.selectAll("path")
      .classed(class_name, function(d) { return state_names.indexOf(d.properties.name) > -1})
  }


  var join_years;
  var centroids;
  d3.json("join_years.json", function(json) { 
    join_years = json
  })

  var current_states = []


  var slider = d3.select("#slider")
  var year = d3.select("#year")
  var update_year = function(_year){
    year.text(_year)
    var slider_width = parseInt(slider.style("width").slice(0, -2))
    var min = parseInt(slider.attr("min"))
    var max = parseInt(slider.attr("max"))
    var slider_pos = (_year - min) / (max - min) * slider_width
    year.style("left", (slider_pos - slider_width / 2) + "px") 
  }
  slider.value = 1750
  update_year(parseInt(slider.value))
  slider.on("change", function(){ 
    var year = parseInt(this.value); 
    update_year(year);
    map_callback(year);
    flag_callback(year);
  }, false);


  function map_callback(year) {

    var states = join_years.filter( function(d) { return d.year <= year})
                                .map( function(d) {return d.states})
                                .reduce( function(s1, s2){ return s1.concat(s2)}, [])

    var new_states = states.filter( function(state) { return current_states.indexOf(state) < 0})

    var past_states = states.filter( function(state) { return current_states.indexOf(state) > -1})

    var states_for_this_year = join_years.filter( function(d) { return d.year === year})
                                .map( function(d) {return d.states})
                                .reduce( function(s1, s2){ return s1.concat(s2)}, [])

    current_states = states


    color_states(past_states, "past")
    color_states(new_states, "new")

    map_group.selectAll(".new")
     .classed("motion", true)
     .transition()
     .duration(1000)
     .attr("transform", function(d) {
       var centroid = path.centroid(d),
       x = centroid[0],
       y = centroid[1];
        return "translate(" + x + "," + y + ")"
       + "scale(" + 1.5 + ")"
       + "translate(" + -x + "," + -y + ")";
     })
     .each(function(){this.parentNode.appendChild(this)})
       .transition()
       .delay(1000)
       .duration(1000)
       .attr("transform", "")
       .each("end", function(){ 
        d3.select(this).classed("motion", false)
                       .classed("new", function(d){ return states_for_this_year.indexOf(d.properties.name) > -1})
                       .classed("past", function(d){ return states_for_this_year.indexOf(d.properties.name) < 0})
        })
    
    console.log(states_for_this_year) 
    color_states(states_for_this_year, "new")
  }

  function flag_callback(year) {

    // remplis ici. Tu peux utiliser star_data qui contient les centroids dans le referentiel du drapeau
  }





  </script>


</body>
</html>